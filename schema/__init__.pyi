import sys
from abc import abstractmethod
from typing import (
    Any,
    List,
    Tuple,
    TypeVar,
    Union,
    Type,
    Callable,
    AnyStr,
    overload,
    Optional as _Optional,
    Pattern,
    NoReturn,
    Sized,
    ClassVar,
    Generic
)

if sys.version_info >= (3, 6):
    from re import RegexFlag
    _FlagsType = Union[int, RegexFlag]
else:
    _FlagsType = int

if sys.version_info >= (3, 8):
    from typing import Porotocol, Final, Literal as _Literal
else:
    from typing_extensions import Protocol, Final, Literal as _Literal


class SupportsValidate(Protocol):
    @abstractmethod
    def validate(self, data: Any) -> Any: ...

T = TypeVar('T')
RT = TypeVar('RT')

Errors = Union[None, str, List[_Optional[str]]]
SchemaInput = Union[
    Union[list, tuple, set, frozenset],
    dict,
    type,
    Literal,
    SupportsValidate,
    Callable[[T], RT],
    Any
]

ST = TypeVar('ST', bound=SchemaInput)

__version__: str
__all__: List[str]

class SchemaError(Exception):
    autos: List[_Optional[str]] = ...
    errors: List[_Optional[str]] = ...

    def __init__(self, autos: Union[str, List[str]], errors: Errors = ...) -> None: ...
    @property
    def code(self) -> str: ...

class SchemaWrongKeyError(SchemaError): ...
class SchemaMissingKeyError(SchemaError): ...
class SchemaOnlyOneAllowedError(SchemaError): ...
class SchemaForbiddenKeyError(SchemaError): ...
class SchemaUnexpectedTypeError(SchemaError): ...

class And(Generic[ST]):
    _args: Tuple[ST, ...] = ...
    _errors: Errors = ...
    _ignore_extra_keys: bool = ...
    _schema: Type[Schema] = ...

    def __init__(self, *args: ST, **kw: Any) -> None: ...
    @property
    def args(self) -> Tuple[ST, ...]: ...
    def validate(self, data: Any) -> Any: ...

class Or(And, Generic[ST]):
    only_one: bool = ...
    match_count: int = ...

    def __init__(self, *args: ST, **kwargs: Any) -> None: ...
    def reset(self) -> None: ...
    def validate(self, data: Any) -> Any: ...

class Regex(Generic[AnyStr]):
    NAMES: Final[ClassVar[List[str]]] = ...
    _pattern_str: AnyStr = ...
    _flags_names: str = ...
    _pattern: AnyStr = ...
    _error: Errors = ...

    def __init__(self, pattern_str: AnyStr, flags: _FlagsType = ..., error: Errors = ...) -> None: ...
    @property
    def pattern_str(self) -> AnyStr: ...
    def validate(self, data: AnyStr) -> AnyStr: ...

class Use:
    _error: Errors = ...

    def __init__(self, callable_: Callable[[T], RT], error: Errors = ...) -> None: ...
    def validate(self, data: T) -> RT: ...

COMPARABLE: Final[_Literal[0]]
CALLABLE: Final[_Literal[1]]
VALIDATOR: Final[_Literal[2]]
TYPE: Final[_Literal[3]]
DICT: Final[_Literal[4]]
ITERABLE: Final[_Literal[5]]

@overload
def _priority(s: Union[list, tuple, set, frozenset]) -> _Literal[5]: ...
@overload
def _priority(s: dict) -> _Literal[4]: ...
@overload
def _priority(s: type) -> _Literal[3]: ...
@overload
def _priority(s: Literal) -> _Literal[0]: ...
@overload
def _priority(s: SupportsValidate) -> _Literal[2]: ...
@overload
def _priority(s: Callable[[T], RT]) -> Union[_Literal[3], _Literal[1]]: ...
@overload
def _priority(s: Any) -> int: ...

class Schema(Generic[ST]):
    as_reference: bool = ...
    _schema: ST = ...
    _error: Errors = ...
    _ignore_extra_keys: bool = ...
    _name: _Optional[str] = ...
    _description: _Optional[str] = ...

    @overload
    def __init__(self, schema: ST, error: Errors = ..., ignore_extra_keys: bool = ..., name: str = ..., description: _Optional[str] = ..., as_reference: _Literal[True] = ...) -> None: ...
    @overload
    def __init__(self, schema: ST, error: Errors = ..., ignore_extra_keys: bool = ..., name: _Optional[str] = ..., description: _Optional[str] = ..., as_reference: _Literal[False] = ...) -> None: ...
    @property
    def schema(self) -> ST: ...
    @property
    def description(self) -> _Optional[str]: ...
    @property
    def name(self) -> _Optional[str]: ...
    @property
    def ignore_extra_keys(self) -> bool: ...
    @staticmethod
    def _dict_key_priority(s: ST) -> Union[float, int]: ...
    @overload
    @staticmethod
    def _is_optional_type(s: Union[Hook, Optional]) -> _Literal[True]: ...
    @overload
    @staticmethod
    def _is_optional_type(s: ST) -> bool: ...
    def is_valid(self, data: Any) -> bool: ...
    def _prepend_schema_name(self, message: str) -> str: ...
    def validate(self, data: Any) -> Any: ...
    def json_schema(self, schema_id: Any, use_refs: bool = ...): ...

class Optional(Schema):
    default: Any = ...
    key: str = ...
    _MARKER: Final[ClassVar[object]]

    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...
    def reset(self) -> None: ...

class Hook(Schema):
    key: Any = ...

    def __init__(self, *args: Any, **kwargs: Any) -> None: ...

class Forbidden(Hook):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def _default_function(nkey: Any, data: Any, error: Errors) -> NoReturn: ...

class Literal:
    _schema: str
    _description: _Optional[str]

    def __init__(self, value: str, description: _Optional[str] = ...) -> None: ...
    @property
    def description(self) -> _Optional[str]: ...
    @property
    def schema(self) -> str: ...

class Const(Schema):
    def validate(self, data: T) -> T: ...

def _callable_str(callable_: Callable) -> str: ...
def _plural_s(sized: Sized) -> int: ...
